브루트포스 - 비트마스크
=======================
* 비트 연산을 사용해서 부분 집합을 표현할 수 있다.  

# 0. 공부하면서 헷갈린 점 (부분 집합 문제)  
N은 데이터의 갯수를 의미한다.    
예를들어 데이터가 5개가 있고 이를 이용하여 집합을 만들었다.    
```{-50, -21, 3, 17, 39}```  
내가 기존에 생각했던 비트 마스크는 -50부터 39까지를 다 표현할 수 있어야 한다는 것이었다.       
즉, ```2^-50``` 부터 ```2^39```의 데이터가 있어야 한다는 것이었다.         
하지만 이는 아니고 그냥 단순히 배열과 비슷하게 인덱스에 존재하는 값이 없으면 0 있으면 1로       
0,0,0,0,0 (전부 없음)부터 1,1,1,1,1 (전부 있음)까지 존재하면 되는 것이었고                   
이는 (1 << 5) == 100000 -> -1 해주어서 1,1,1,1,1 로 나타내주면 된다.          

# 1. 비트 연산

* & AND
* | OR
* ~ NOT 
* ^ XOR
___

* 두 수 A와 B를 비트 연산 하는 경우에는 가장 뒤의 자리부터 하나씩 연산을 수행하면 된다.  
* A = 27, B = 83인 경우  
* A = 0011011 , B = 1010011
* A & B = 0010011 -> 19
* A | B = 1011011 -> 91
* A ^ B = 1001000 -> 72
___

* not 연산의 경우에는 자료형에 따라 결과가 달라진다.  
* A = 83 = 1010011
* -A = 10101100 (8비트 자료형)
* ~A = 11111111 11111111 11111111 10101100 (32비트 자료형)
* 또 unsigned, signed에 따라서 보여지는 값은 다르다.  

___

* shift left (<<)와 shift right(>>) 연산이 있다.  
* A << B (A를 왼쪽으로 B비트 만큼 밀어라)   
* 1 << 0 = 1
* 1 << 1 = 2
* 1 << 2 = 4 
* 1 << 3 = 8
* 1 << 4 = 16
* 3 << 3 = 24
* 5 << 10 = 5120
* A >> B (A를 오른쪽으로 B비트 만큼 밀어라)   
* 1 >> 0 = 1
* 1 >> 1 = 0
* 10 >> 1 = 5 
* 10 >> 2 = 2
* 10 >> 3 = 1
* 30 >> 1 = 15
* 1024 << 10 = 1

___

그래서 코딩을 할때 2^n을 얻으려면 ```1 << n``` 을 사용해도 된다.
* A << B == A * 2^B
* A >> B == A / 2^B
* (A+B/2) == A+B >> 1로 쓸 수 있다.   
   
단 비트 연산자를 이용할 때 주의점이 한가지 있는데 바로 연산자 우선순위이다.  
그렇기에 연산자 우선순위에 맞게 작성해주던가 괄호를 사용해주도록 하자  

# 2. 비트 마스크
* 정수로 집합을 나타낼 수 있다.  
* {1,3,4,5,9} = 570 = 2^**1** + 2^**3** + 2^**3** + 2^**5** + 2^**9**
* 집합에는 같은 수가 없다 값이 있거나 없거나 둘 중 하나이다.
* 숫자를 단순하게 비트의 자릿수로 표현하여 나타낼 수 있는 것이다.  
   
비트 마스크의 장점 :    
1. 집합을 단순히 배열로 나타내자면 최소 갯수만큼이 필요한데 비트 마스크는 정수 1개의 공간만 필요로한다.  
2. 정수라는 것이 2번째 장점이다 -> 배열의 인덱스로 사용할 수 있다. ```A[570]```
      
비트 마스크를 사용할 때에는 사용하려고 하는 수가 최대 몇개 있는지를 알아봐야 한다.      
즉, 이 집합에 들어갈 수 있는 최대 값을 알아야 한다.      
예를 들면 32 이상의 값이 들어온다면 32비트인 int로는 처리를 할 수 없다.      
   
* 보통 N개 일 경우 0부터 N-1까지 정수로 이루어진 집합을 나타낼때 사용한다.         
* 0이 아닌 1부터 N까지 정수로 이루어진 집합을 사용하는 건 공간이 2배더 필요하다. ``` << 1 이나 >> 1 이므로 ```          
* 또, 각종 연산을 조금 변형해서 사용해야 한다.       
* 따라서, 0부터 N-1까지로 변형해서 사용하는 것이 더 좋다.    

# 3. 비트 마스크와 비트 연산
**검사 연산**   
* {1,3,4,5,9} = 570
* 집합에 0 이 포함되어 있는지 검사  
   * 570 & 2^0 = 570 & (1 << 0) = 0
* 집합에 1 이 포함되어 있는지 검사  
   * 570 & 2^**1** = 570 & (1 << 1) = 2
* 집합에 2 가 포함되어 있는지 검사  
   * 570 & 2^**2** = 570 & (1 << 2) = 0 -> 같은 것만 추출하니까 없으면 0 나옴
* 집합에 3 이 포함되어 있는지 검사  
   * 570 & 2^**3** = 570 & (1 << 3) = 8 -> 같은 것만 추출하니까 있으면 값 나옴
___    
**추가 연산**     

* {1,3,4,5,9} = 570
* 1추가 하기  
   * 570 | 2^**1** = 570 | (1 << 1) = 570 -> 있으니까 그대로
* 2추가 하기  
   * 570 | 2^**2** = 574 | (1 << 2) = 574 -> 없으니까 2^2 추가
* 3추가 하기  
   * 570 | 2^**3** = 570 | (1 << 3) = 570 -> 있으니까 그대로
* 4추가 하기  
   * 570 | 2^**4** = 570 | (1 << 4) = 570 -> 있으니까 그대로
* 6추가 하기  
   * 570 | 2^**6** = 633 | (1 << 6) = 633 -> 없으니까 2^6 추가
___   
**제거 연산**     
비트를 연산을 하고 보수를 취해준다.      
그리고 AND 연산자를 통해서 삭제시켜준다.          
 
* {1,3,4,5,9} = 570
* 1제거 하기  
   * 570 & -2^**1** = 570 & ~(1 << 1) = 568 -> 있으니까 2^1 값 빼짐
* 2제거 하기  
   * 570 & -2^**2** = 570 & ~(1 << 2) = 570 -> 없으니까 그대로
* 3제거 하기  
   * 570 & -2^**3** = 570 & ~(1 << 3) = 562 -> 있으니까 2^3 값 빼짐
* 4제거 하기  
   * 570 & -2^**4** = 570 & ~(1 << 4) = 554 -> 있으니까 2^4 값 빼짐
___
**토글 연산**     
즉 없으면 추가시키고 있으면 빼준다.
^ XOR 같은 경우의 ```1-0 이면 1``` ```1-1 이면 0``` 원리를 이용한 것이다.  

* {1,3,4,5,9} = 570
* 1토글 하기  
   * 570 ^ 2^**1** = 570  ^ (1 << 1) = 568 -> 있으니까 2^1 값 빼짐
* 2토글 하기  
   * 570 ^ 2^**2** = 570  ^ (1 << 2) = 574 -> 없으니까 2^2 값 추가
* 3토글 하기  
   * 570 ^ 2^**3** = 570  ^ (1 << 3) = 562 -> 있으니까 2^3 값 빼짐
* 4토글 하기  
   * 570 ^ 2^**4** = 570  ^ (1 << 4) = 554 -> 있으니까 2^4 값 빼짐     
___
* **전체 집합**       
   * (1 << N) -1     
   * N이 7이라고 가정시에 집합이 {1,2,3,4,5,6,7}이라고 가정시에는 11111110 의 형태가 된다.
   * 이를 실제로 대입시켜보면 10000000
   
* **공 집합**   
   * 0
___
**요약**     
현재 집합이 S일때  
* i 를 추가
   * S | (1 << i)
* i 를 검사
   * S & (1 << i)
* i 를 제거
   * S & ~(1 << i)
* i 를 토글 
   * S ^ (1 << i)  
      
비트 마스크를 이용해서 문제를 푸는 경우는    
문제에 할 수 있는 것이 N개가 있고 그 때 일부를 선택해서 할 수 있을 때 모든 방법을 만드는 경우에 사용한다.  
그래서 비트 마스크는 해야할 일이 항상 정해져있고 그때 2^N 으로 만들수 있으면 할 수 있다.
  
# 4 집합
0부터 N-1로 사용해야 하므로 들어온 값을 -1 처리를 해줘야한다.      
    
그래야 들어온 값이 ```1 << x-1``` 형태가 되어     
만약 1이 들어왔다면 ```1 << 1``` 은 2배가 되는 형태이므로 불상사가 생기므로      
``` 1 << 0```형태로 해주기 위해서이다.          
    
add 1 -> ```집합 | 1 << 0``` 이 되어야 한다.   


**집합**   
```c++
#include <cstdio>
#include <cstring>
using namespace std;
char b[111];
int main() {
    int n = 20;
    int m;
    scanf("%d",&m);
    int s = 0;
    int x;
    while (m--) {
        scanf("%s",b);
        if (!strcmp(b,"add")) {
            scanf("%d",&x); x--;
            s = (s | (1 << x));
        } else if (!strcmp(b,"remove")) {
            scanf("%d",&x); x--;
            s = (s & ~(1 << x));
        } else if (!strcmp(b,"check")) {
            scanf("%d",&x); x--;
            int res = (s & (1 << x));
            if (res) {
                puts("1");
            } else {
                puts("0");
            }
        } else if (!strcmp(b,"toggle")) {
            scanf("%d",&x); x--;
            s = (s ^ (1 << x));
        } else if (!strcmp(b,"all")) {
            s = (1<<n)-1;
        } else if (!strcmp(b,"empty")) {
            s = 0;
        }
    }
    return 0;
}
```
# 5. 부분 집합의 합  
* 서로 다른 N개의 정수로 이루어진 집합이 있을 때,   
이 집합의 공집합이 아닌 부분집합 중에서 그 집합의 원소를 다 더한 값이 s가 되는 경우의 수를 구하는 문제    
* 1 <= N <= 20     
* 모든 집합의 개수 = 2^N    
* 모든 집합을 구해보면 된다!  

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
using namespace std;

vector<int> a(20);
int main() {
	int n , s;
	cin >> n >> s;

	for (int i=0; i<n; i++) {
        cin >> a[i];
    }

	int ans = 0;
	for(int i=1; i < (1 << n); i++){ // 전체 집합
		int sum = 0;
		for(int k=0; k < n; k++){ // 그 중 무엇이 포함되었는지 확인하는 반복문 
			if(i & (1<<k)){ // 각각의 K번재 수가 포함되었는지 확인 
				sum += a[k];
			}
		}
		if(sum == s){
			ans += 1;
		}
	}

	cout << ans << "\n";
	return 0;
}

```


# 6. bitset   
* C++ 기준으로 int는 32비트, longlong 은 64비트이다.
* 64비트를 넘는 비트는 정수로 나타낼 수 없다.   
* 이런 경우에는 C++은 bitset을 이용하면 된다. (128비트로 만들 수 있다.)





